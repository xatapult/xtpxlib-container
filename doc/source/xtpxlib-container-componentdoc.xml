<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../../../xtpxlib-xdoc/xsd/docbook/docbook.nvdl" type="application/xml" schematypens="http://purl.oclc.org/dsdl/nvdl/ns/structure/1.0"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xdoc="http://www.xtpxlib.nl/ns/xdoc" version="5.0">
  <!-- ================================================================== -->
  <!--
    Source for this component's documentation.
  -->
  <!-- ================================================================== -->

  <info>
    <title>{$component-name}</title>
    <subtitle>XML Container Handling</subtitle>
    <pubdate>{$DATE}</pubdate>
    <author>
      <personname>{$author-name}</personname>
    </author>
    <orgname>{$owner-company-name}</orgname>
  </info>

  <!-- ================================================================== -->

  <preface>
    <title>{$library-name} - XML Container Handling</title>

    <xdoc:transform href="../../../xtpxlib-webdoc/transforms/generate-basic-component-information-header.xpl" component-name="{$component-name}"/>

  </preface>

  <!-- ================================================================== -->

  <chapter xml:id="chapter-description">
    <title>Description</title>

    <para>In working with XML or HTML, it is often the case that you need to work with multiple documents <emphasis>at the same time</emphasis>. And
      in most cases that's rather awkward. For instance, an XSLT transformation processes a single document. And yes, of course you can get others by
      calling the <code>doc()</code> function or produce others using <tag>xsl:result-document</tag>. But, especially when there are a lot of
      relations between the documents, this requires careful and sometimes heavy programming. The idea of <emphasis>XML&#160;containers</emphasis>
      tries to make this more manageable.</para>


    <para>An XML container (as handled/used by this module) is an XML structure that holds other XML documents and references to binary files. Here is
      a short example:</para>

    <example xml:id="example-container-1">
      <title>Example of an XML container</title>
      <programlisting><xi:include href="listings/example-container.xml" parse="text"/></programlisting>
    </example>

    <para>This example shows a container, probably generated by some pipeline or XSLT stylesheet, that contains the contents of a simple website. All
      two pages and some image are there. Running this container through <code><link linkend="container.mod.xpl-xtlcon_container-to-disk"
          >xtlcon:container-to-disk</link></code> will write it to the path indicated in <code>/*/@href-target-path</code>:
        <code>/my/website/location</code>. The documents <code>index.html</code> and <code>page1.html</code> come from the container, the binary
        <code>image.jpg</code> is copied from the indicated source location. Because everything, every separate file, is in (or referenced in) a
      single encompassing document, lots of things get easier: creating or checking internal referencing, making classes consistent, etc. An XSLT
      stylesheet that gets this as its main document has access to <emphasis>all</emphasis> information.</para>
    <para role="halfbreak"/>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect1>
      <title>Applications</title>

      <para>As it turned out, the whole idea of working with multiple documents in an XML container had several applications:</para>
      <itemizedlist>
        <listitem>
          <para>An important application of the zip format is its use as an overarching storage format for applications. For instance, most office
            suites do this: a Microsoft Word <code>.docx</code> or Excel <code>.xlsx</code> file is actually a zip file with many smaller files inside
            (most of them in XML format). There are many other examples.</para>
          <para>Trying to interpret such a zip file and get something meaningful out of it can be a nightmarish experience, especially if you want to
            follow the standard (and not rely on some file naming convention some engineer cooked up and might change). It takes following links
            through several files to the place the actual interesting information is stored.</para>
          <para>But if you run such a file through <code><link linkend="container.mod.xpl-xtlcon_zip-to-container"
              >xtlcon:zip-to-container</link></code> you get all files in a single encompassing one, making it much, much easier to follow internal
            links and find the right information. The <code><link xlink:href="https://xoffice.xtpxlib.org">xtpxlib-xoffice</link></code> component
            does exactly this: it contains pipelines to get the contents of Word and Excel files in an easier to interpret XML format.</para>
        </listitem>
        <listitem>
          <para>Going even further with this, it is now much easier to <emphasis>change</emphasis> or even <emphasis>create</emphasis> such a horribly
            complex Word, Excel or other kind of office zip file:</para>
          <itemizedlist>
            <listitem>
              <para>Read a (template) office document in using <code><link linkend="container.mod.xpl-xtlcon_zip-to-container"
                    >xtlcon:zip-to-container</link></code>. </para>
            </listitem>
            <listitem>
              <para>Change what you need to change (text, spreadsheet cell values, etc.). Leave the rest, with all this complex linking and other
                stuff you don't really need to understand, alone.</para>
            </listitem>
            <listitem>
              <para>Write it to a resulting zip file using <code><link linkend="container.mod.xpl-xtlcon_container-to-zip"
                    >xtlcon:container-to-zip</link></code>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>A file structure that needs to end up on disk or in a zip file can be created easily using this XML container mechanism.</para>
        </listitem>

      </itemizedlist>

    </sect1>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect1>
      <title>Working with containers</title>

      <para>The container format is described <link linkend="chapter-container-format">here</link> Working with XML container documents is done using
          <link linkend="chapter-xproc-libraries">XProc 1.0</link> or <link linkend="chapter-xproc-libraries">XProc 3.0</link> pipelines.</para>

      <para><emphasis role="bold">WARNING:</emphasis> The container formats and processing features differ between the 1.0 and the 3.0 version! More
        about this in the <link linkend="chapter-container-format">container format description</link>.</para>

      <para role="halfbreak"/>
      <para>There are some notable missing features in the current container handling. These are not impossible to implement, the need for them just
        hasn't arisen yet.</para>
      <itemizedlist>
        <listitem>
          <para>When writing a zip file you cannot control the compression (different ones, on or off). This means that this mechanism currently can't
            produce e-books (which require an uncompressed first file). </para>
        </listitem>
        <listitem>
          <para>You can't work with binary contents <emphasis>inside</emphasis> the container, for instance when its <code>base64</code>
            encoded.</para>
        </listitem>
      </itemizedlist>
    </sect1>

  </chapter>

  <!-- ================================================================== -->

  <chapter xml:id="chapter-container-format">
    <title>Container format</title>

    <para><emphasis role="bold">WARNING:</emphasis> The container formats and processing features differ between the XProc 1.0 and the 3.0
      version!</para>
    <itemizedlist>
      <listitem>
        <para><link linkend="container-format-xproc-1">Description of the container format for XProc 1.0</link></para>
      </listitem>
      <listitem>
        <para><link linkend="container-format-xproc-3">Description of the container format for XProc 3.0</link></para>
      </listitem>
    </itemizedlist>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect1 xml:id="container-format-xproc-1">
      <title>XProc 1.0 container format</title>

      <para>The schema for the XProc 1.0 container format can be found in <code>xsd/container.xsd</code>.</para>

      <para role="keep-with-next">The root of an XProc&#160;1.0 XML container document is an <tag>xtlcon:document-container</tag> element. The prefix
          <code>xtlcon:</code> must be bound to the namespace <code>http://www.xtpxlib.nl/ns/container</code>
          (<code>xmlns:xtlcon="http://www.xtpxlib.nl/ns/container"</code>).</para>

      <xdoc:transform href="$xdoc/xml-description.xpl">
        <xi:include href="xml-descriptions/description-document-container.xml"/>
      </xdoc:transform>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="sect-internal-documents">
        <title>Internal documents</title>

        <para role="keep-with-next">An <emphasis>internal</emphasis> document is a document whose contents is inside the container document. This will
          in most cases be XML documents, but text is also possible. It must be surrounded by an <tag>xtlcon:document</tag> element:</para>


        <xdoc:transform href="$xdoc/xml-description.xpl">
          <xi:include href="xml-descriptions/description-document.xml"/>
        </xdoc:transform>

      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="sect-external-documents">
        <title>External documents</title>

        <para role="keep-with-next">An <emphasis>external</emphasis> document is a document that is only referenced from the container. Usually binary
          files but anything goes. The referencing is done using an <tag>xtlcon:external-document</tag> element:</para>

        <xdoc:transform href="$xdoc/xml-description.xpl">
          <xi:include href="xml-descriptions/description-external-document.xml"/>
        </xdoc:transform>

      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="sect-container-document-mime-type-values">
        <title>Document MIME type values</title>

        <para>The <code>xtlcon:document/@mime-type</code> attribute (see <link linkend="sect-internal-documents">Internal documents</link>) can
          trigger some special treatment of the contents of the element:</para>

        <variablelist>
          <varlistentry>
            <term><code>mime-type="application/pdf"</code>
              <emphasis>and</emphasis> the root element is <tag>fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format"</tag></term>
            <listitem>
              <para>The document is assumed to be an XSL-FO document and the FOP XSL-FO processor is called to create a PDF document. The pipelines
                (both <code><link linkend="container.mod.xpl-xtlcon_container-to-disk">xtlcon:container-to-disk</link></code> and <code><link
                    linkend="container.mod.xpl-xtlcon_container-to-zip">xtlcon:container-to-zip</link></code>) allow you to specify an FOP
                configuration file.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><code>mime-type="text/plain"</code></term>
            <listitem>
              <para>The contents of the <tag>xtlcon:document</tag> element will be stringified and stored as text. The schema requires some root
                element to be present as child of <tag>xtlcon:document</tag> but this is ignored:</para>
              <programlisting><![CDATA[<xtlcon:documnent mime-type="text/plain" …>
<dummy-root>Text to be stored
another line…</dummy-root>
</xtlcon:document>]]></programlisting>
            </listitem>
          </varlistentry>
        </variablelist>
      </sect2>

    </sect1>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect1 xml:id="container-format-xproc-3">
      <title>XProc 3.0 container format</title>

      <para>The container format for XProc&#160;3.0 allows documents in XML, HTML, text and JSON format. It can also process JSON as XML.</para>

      <para>The schema for the XProc 3.0 container format can be found in <code>xsd/container-xpl3.xsd</code>.</para>

      <para role="keep-with-next">The root of an XProc&#160;3.0 XML container document is an <tag>xtlcon:document-container</tag> element. The prefix
          <code>xtlcon:</code> must be bound to the namespace <code>http://www.xtpxlib.nl/ns/container</code>
          (<code>xmlns:xtlcon="http://www.xtpxlib.nl/ns/container"</code>).</para>

      <note>
        <para>When you get the container back after processing by one of the pipelines, you'll find most href related attributes (attributes that
          start with <code>href-</code>) copied to an attribute with the same name plus an underscore in front. The values of these added attributes
          will be the fully expanded and canonicalized references.</para>
        <para>For instance: When the container has an attribute <code>href-target-zip="../out.zip"</code>, after processing you'll find an attribute
          like <code>_href-target-zip="file:///ful/path/to/out.zip"</code> on the result.</para>
      </note>

      <para role="break"/>

      <xdoc:transform href="$xdoc/xml-description.xpl">
        <xi:include href="xml-descriptions/xproc3-description-document-container.xml"/>
      </xdoc:transform>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="sect-xproc3-internal-documents">
        <title>Internal documents</title>

        <para role="keep-with-next">An <emphasis>internal</emphasis> document is a document whose contents is <emphasis>inside</emphasis> the
          container document. It must be surrounded by an <tag>xtlcon:document</tag> element.</para>


        <xdoc:transform href="$xdoc/xml-description.xpl">
          <xi:include href="xml-descriptions/xproc3-description-document.xml"/>
        </xdoc:transform>

      </sect2>

      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

      <sect2 xml:id="sect-xproc3-external-documents">
        <title>External documents</title>

        <para role="keep-with-next">An <emphasis>external</emphasis> document is a document that is only referenced from the container. Usually binary
          files but anything goes. The referencing is done using an <tag>xtlcon:external-document</tag> element:</para>

        <xdoc:transform href="$xdoc/xml-description.xpl">
          <xi:include href="xml-descriptions/xproc3-description-external-document.xml"/>
        </xdoc:transform>

      </sect2>

    </sect1>


  </chapter>

  <!-- ================================================================== -->

  <chapter xml:id="chapter-xproc-libraries" xreflabel="XProc 1.0 Libraries">
    <title>XProc 1.0 Libraries</title>

    <para>The {$component-name} component contains the following XProc (1.0) library module:</para>

    <xdoc:transform href="$xdoc/code-docgen-dir.xpl" dir="../../../xtpxlib-container/xplmod/" filter="\.mod\.xpl$" header-level="1" filecomponents="3"
      sublevels="true"/>

  </chapter>

  <!-- ======================================================================= -->

  <chapter xml:id="chapter-xproc-3-libraries" xreflabel="XProc 3.0 Support">
    <title>XProc 3.0 Support</title>

    <para>The {$component-name} component contains the following support (pipelines and/or libraries) for XProc 3.0:</para>

    <xdoc:transform href="$xdoc/code-docgen-dir.xpl" dir="../../../xtpxlib-container/xpl3mod/" filter=".+\.xpl$" header-level="1" filecomponents="3"
      sublevels="true" id-suffix="xproc3-"/>

  </chapter>

  <!-- ================================================================== -->

  <chapter xml:id="chapter-xml-schemas" xreflabel="XML Schemas">
    <title>XML Schemas</title>

    <para>The {$component-name} component contains the following XML Schemas:</para>

    <xdoc:transform href="$xdoc/code-docgen-dir.xpl" dir="../../../xtpxlib-container/xsd/" filter="\.xsd$" header-level="1" filecomponents="2"
      sublevels="true"/>

  </chapter>

</book>
